<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UHI Predicter by ASBEE</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Leaflet CSS & JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <!-- Leaflet Draw CSS & JS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <!-- osmtogeojson for converting OSM data -->
    <script src="https://unpkg.com/osmtogeojson@3.0.0-beta.5/osmtogeojson.js"></script>
    <!-- three.js for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Chart.js for plotting results -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        #map { height: 100vh; width: 100%; cursor: crosshair; }
        .leaflet-draw-toolbar a, .leaflet-draw-actions a { background-color: white !important; border-radius: 0.375rem !important; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .info-panel {
            position: absolute; top: 1rem; left: 3.5rem; z-index: 1000;
            background: white; padding: 1rem; border-radius: 0.5rem; box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            width: 420px; max-width: calc(100% - 4.5rem); max-height: calc(100vh - 2rem); overflow-y: auto;
        }
        .placeholder-text {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            color: #9ca3af;
            font-size: 0.875rem;
            padding: 1rem;
        }
        #nolli-container, #3d-container { border: 2px dashed #d1d5db; background-color: #f9fafb; }
        button:disabled { background-color: #9ca3af; cursor: not-allowed; opacity: 0.7; }
        .spinner { animation: spin 1s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        /* Styles for About Panel */
        #about-panel h3 { font-size: 1.1rem; font-weight: 600; margin-top: 1rem; border-bottom: 1px solid #e5e7eb; padding-bottom: 0.25rem; }
        #about-panel p, #about-panel li { font-size: 0.875rem; color: #4b5563; line-height: 1.5; }
        #about-panel ul { list-style-type: disc; padding-left: 1.5rem; margin-top: 0.5rem; }
        #about-panel strong { color: #1f2937; }
    </style>
</head>
<body class="bg-gray-100">

    <div id="map"></div>

    <div class="info-panel">
        <div class="flex flex-col space-y-4">
            <img src="logo1.jpeg" alt="ASBEE Logo" class="h-16 w-auto object-contain mx-auto mb-2">
            <h1 class="text-xl font-bold text-gray-800 text-center">UHI Predictor</h1>
            <p class="text-sm text-gray-600 text-center -mt-3">
                Define building geometry, generate a 3D model, then run a UHI simulation.
            </p>

            <div id="notification" class="hidden p-3 rounded-lg text-sm text-white transition-opacity"></div>

            <div class="flex space-x-2">
                <button id="identify-btn" class="w-full bg-green-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 transition duration-200 flex items-center justify-center space-x-2">
                    <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 3.5a5.5 5.5 0 100 11 5.5 5.5 0 000-11zM2 9a7 7 0 1112.452 4.391l3.328 3.329a.75.75 0 001.06-1.06l-3.329-3.328A7 7 0 012 9z" clip-rule="evenodd" /></svg>
                    <span>Identify</span>
                    <svg id="identify-spinner" class="spinner h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                </button>
                 <button id="clear-btn" class="w-full bg-red-500 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-400 transition duration-200 flex items-center justify-center space-x-2" disabled>
                    <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M8.75 1A2.75 2.75 0 006 3.75v.443c-1.157.06-2.135.433-2.852 1.012A.75.75 0 002.5 6h15a.75.75 0 00.602-.994c-.717-.58-1.695-.952-2.852-1.012v-.443A2.75 2.75 0 0011.25 1h-2.5zM3.5 8.75c0-.414.336-.75.75-.75h11.5a.75.75 0 010 1.5H4.25a.75.75 0 01-.75-.75zM5 11.25a.75.75 0 01.75-.75h8.5a.75.75 0 010 1.5h-8.5a.75.75 0 01-.75-.75z" clip-rule="evenodd" /></svg>
                    <span>Clear</span>
                </button>
            </div>

            <!-- Tab Navigation -->
            <div class="border-b border-gray-200 mt-4">
                <nav class="-mb-px flex space-x-4" aria-label="Tabs">
                    <button id="tab-nolli" class="whitespace-nowrap py-3 px-1 border-b-2 font-semibold text-sm border-blue-500 text-blue-600">Nolli Map</button>
                    <button id="tab-3d" class="whitespace-nowrap py-3 px-1 border-b-2 font-semibold text-sm border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300">3D Model</button>
                    <button id="tab-uhi" class="whitespace-nowrap py-3 px-1 border-b-2 font-semibold text-sm border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 disabled:opacity-50 disabled:hover:border-transparent disabled:cursor-not-allowed" disabled>UHI Simulation</button>
                    <button id="tab-about" class="whitespace-nowrap py-3 px-1 border-b-2 font-semibold text-sm border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300">About</button>
                </nav>
            </div>
            
            <!-- Panels -->
            <div id="nolli-panel" class="space-y-2">
                <button id="generate-nolli-btn" class="w-full bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg" disabled>Generate Nolli Map</button>
                <div id="nolli-container" class="w-full h-64 rounded-lg overflow-hidden">
                    <div class="placeholder-text">Identify or draw buildings on the map to generate a Nolli-style plan.</div>
                </div>
            </div>

            <div id="3d-panel" class="space-y-2 hidden">
                <div class="flex items-center space-x-2"><label for="building-height" class="text-sm font-medium">Avg. Height (m):</label><input type="number" id="building-height" value="30" min="1" class="w-full p-1 border rounded-md"></div>
                <button id="generate-3d-btn" class="w-full bg-purple-600 text-white font-semibold py-2 px-4 rounded-lg" disabled>Generate 3D Model</button>
                <div id="3d-container" class="w-full h-64 rounded-lg overflow-hidden relative bg-gray-200 cursor-move">
                    <div class="placeholder-text">Generate a 3D model to visualize the urban form.</div>
                </div>
            </div>

            <div id="uhi-panel" class="space-y-4 hidden">
                <!-- Inputs -->
                <h3 class="font-semibold text-gray-700">Simulation Inputs</h3>
                <div>
                    <label class="block text-sm font-medium text-gray-700">EPW Weather File</label>
                    <input type="file" id="epw-file-input" accept=".epw" class="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"/>
                    <p id="epw-file-name" class="text-xs text-gray-500 mt-1 truncate"></p>
                </div>
                <div>
                    <label for="wwr-input" class="block text-sm font-medium">Window-to-Wall Ratio</label>
                    <input type="number" id="wwr-input" value="0.25" min="0" max="1" step="0.05" class="mt-1 w-full p-1 border rounded-md">
                </div>
                 <div>
                    <label for="solstice-select" class="block text-sm font-medium">Simulation Period</label>
                    <select id="solstice-select" class="mt-1 w-full p-1 border rounded-md">
                        <option value="summer">Summer Solstice (June 21)</option>
                        <option value="winter">Winter Solstice (Dec 21)</option>
                    </select>
                </div>
                <div>
                    <label for="green-cover-input" class="block text-sm font-medium">Green Cover Ratio (%)</label>
                    <input type="number" id="green-cover-input" value="20" min="0" max="100" step="1" class="mt-1 w-full p-1 border rounded-md">
                </div>
                <div>
                    <label for="building-albedo-input" class="block text-sm font-medium">Building Albedo</label>
                    <input type="number" id="building-albedo-input" value="0.3" min="0" max="1" step="0.05" class="mt-1 w-full p-1 border rounded-md">
                </div>
                <div>
                    <label for="pavement-albedo-input" class="block text-sm font-medium">Pavement Albedo</label>
                    <input type="number" id="pavement-albedo-input" value="0.1" min="0" max="1" step="0.05" class="mt-1 w-full p-1 border rounded-md">
                </div>
                
                <h3 class="font-semibold text-gray-700 pt-4 border-t">Urban Form Parameters</h3>
                <div class="text-sm space-y-1 bg-gray-50 p-3 rounded-md">
                    <p><strong>Building Density:</strong> <span id="param-bldg-density">-</span></p>
                    <p><strong>Aspect Ratio (H/W):</strong> <span id="param-aspect-ratio">-</span></p>
                    <p><strong>Site Area:</strong> <span id="param-site-area">-</span> m²</p>
                    <p><strong>Built Volume:</strong> <span id="param-built-volume">-</span> m³</p>
                    <p><strong>Roof Area:</strong> <span id="param-roof-area">-</span> m²</p>
                    <p><strong>Surface/Volume Ratio:</strong> <span id="param-sv-ratio">-</span></p>
                </div>

                <button id="run-simulation-btn" class="w-full bg-green-600 text-white font-semibold py-2 px-4 rounded-lg flex items-center justify-center space-x-2" disabled>
                    <span>Run Simulation</span>
                    <svg id="uhi-spinner" class="spinner h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path></svg>
                </button>

                 <!-- Results -->
                <div id="chart-container" class="mt-2 relative h-80 w-full">
                     <div id="chart-placeholder" class="placeholder-text">Run a simulation to see the Urban Heat Island effect results.</div>
                     <canvas id="uhi-chart"></canvas>
                </div>
            </div>

            <div id="about-panel" class="space-y-2 hidden">
                <h3>About the Tool</h3>
                <p>The <strong>UHI Predicter by ASBEE</strong> is an interactive web tool designed for architects, urban planners, and students to explore the relationship between urban form and the Urban Heat Island (UHI) effect. It provides a simplified, visual method to assess how changes in urban geometry and material properties can influence local temperatures.</p>
                <p>This tool was created by <strong>Milan Ben</strong> as an aid for sustainable building and environmental engineering education.</p>
                
                <h3>Calculations & Variables</h3>
                <p>The tool uses a simplified parametric model, not a full physics-based simulation. The Urban Temperature is calculated as the baseline Rural Temperature (from the EPW file) plus a calculated UHI Effect.</p>
                <ul>
                    <li><strong>Urban Form:</strong> Key metrics like Building Density, Aspect Ratio, and Surface-to-Volume Ratio are calculated from the building geometry you define on the map.</li>
                    <li><strong>Daytime UHI Effect:</strong> Calculated based on solar energy absorbed by surfaces (factoring in albedo), heat trapped by urban geometry (density and aspect ratio), cooling from green cover, and an estimate for anthropogenic (human-caused) heat.</li>
                    <li><strong>Nighttime UHI Effect:</strong> Calculated based on the slow release of heat stored in the urban fabric during the day, plus ongoing anthropogenic heat.</li>
                    <li><strong>Key Inputs:</strong> Building Albedo, Pavement Albedo, Green Cover Ratio, and Window-to-Wall Ratio directly influence the energy balance calculations.</li>
                </ul>

                <h3>Assumptions & Limitations</h3>
                <ul>
                    <li><strong>Simplified Physics:</strong> This is an educational and exploratory tool. It uses simplified relationships to estimate UHI and is not a substitute for detailed scientific simulations like Computational Fluid Dynamics (CFD).</li>
                    <li><strong>Uniform Properties:</strong> All buildings are assumed to have the same average height and albedo. Pavements are also assumed to have a single albedo value.</li>
                    <li><strong>No Wind or Humidity:</strong> The model does not account for the significant effects of wind (which can dissipate heat) or humidity on thermal comfort.</li>
                    <li><strong>Basic Anthropogenic Heat:</strong> The heat from traffic, HVAC systems, and human activity is represented by a very basic proxy based on density and WWR.</li>
                    <li><strong>Data Dependency:</strong> The accuracy of the results depends entirely on the quality of the underlying OpenStreetMap data and the selected EPW weather file.</li>
                </ul>
                <p class="mt-4 text-xs text-gray-400">AI-assisted development: This tool's code and explanatory text were generated with assistance from Google's Gemini.</p>
            </div>
        </div>
    </div>
    
    <script type="module">
        // --- Main App Setup ---
        const map = L.map('map').setView([41.9028, 12.4964], 15); // Default view (Rome)
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>', maxZoom: 20
        }).addTo(map);

        // --- Geolocation: Center map on user's location on load ---
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                (position) => map.setView([position.coords.latitude, position.coords.longitude], 15),
                () => console.log("Geolocation permission denied. Defaulting to Rome.")
            );
        }

        const drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);
        map.addControl(new L.Control.Draw({ edit: { featureGroup: drawnItems }, draw: { polygon: { shapeOptions: { color: '#3b82f6', fillColor: '#60a5fa', fillOpacity: 0.5 } }, polyline: false, rectangle: false, circle: false, marker: false, circlemarker: false }}));

        let uhiChart;

        // --- UI Element References ---
        const notificationEl = document.getElementById('notification');
        const identifyBtn = document.getElementById('identify-btn');
        const identifySpinner = document.getElementById('identify-spinner');
        const clearBtn = document.getElementById('clear-btn');
        // Tabs
        const tabNolli = document.getElementById('tab-nolli');
        const tab3D = document.getElementById('tab-3d');
        const tabUhi = document.getElementById('tab-uhi');
        const tabAbout = document.getElementById('tab-about');
        // Panels
        const nolliPanel = document.getElementById('nolli-panel');
        const threeDPanel = document.getElementById('3d-panel');
        const uhiPanel = document.getElementById('uhi-panel');
        const aboutPanel = document.getElementById('about-panel');
        // Nolli elements
        const generateNolliBtn = document.getElementById('generate-nolli-btn');
        const nolliContainer = document.getElementById('nolli-container');
        // 3D elements
        const generate3dBtn = document.getElementById('generate-3d-btn');
        const threeDContainer = document.getElementById('3d-container');
        const buildingHeightInput = document.getElementById('building-height');
        // UHI elements
        const epwFileInput = document.getElementById('epw-file-input');
        const epwFileNameEl = document.getElementById('epw-file-name');
        const runSimulationBtn = document.getElementById('run-simulation-btn');
        const uhiSpinner = document.getElementById('uhi-spinner');
        const chartPlaceholder = document.getElementById('chart-placeholder');


        // --- Core App Logic ---
        function showNotification(message, isError = false) {
            notificationEl.textContent = message;
            notificationEl.className = `p-3 rounded-lg text-sm text-white transition-opacity ${isError ? 'bg-red-500' : 'bg-blue-500'}`;
            notificationEl.classList.remove('hidden');
            setTimeout(() => notificationEl.classList.add('hidden'), 5000);
        }

        function updateButtonStates() {
            const hasLayers = drawnItems.getLayers().length > 0;
            [clearBtn, generateNolliBtn, generate3dBtn].forEach(btn => btn.disabled = !hasLayers);
            tabUhi.disabled = true; // Always disable UHI tab on geometry change until 3D model is regenerated
        }

        async function identifyBuildings() {
            identifySpinner.classList.remove('hidden');
            identifyBtn.disabled = true;
            const bounds = map.getBounds();
            const bbox = `${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()}`;
            const query = `[out:json][timeout:25];(way["building"](${bbox});relation["building"](${bbox}););out body;>;out skel qt;`;
            try {
                const response = await fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`);
                if (!response.ok) throw new Error(`Server error: ${response.status}`);
                const osmData = await response.json();
                const geojsonData = osmtogeojson(osmData);
                drawnItems.clearLayers();
                
                if (geojsonData.features.length === 0) {
                    showNotification("No building data found in the current map view.", true);
                } else {
                    L.geoJSON(geojsonData, { style: { color: '#22c55e', fillOpacity: 0.5, weight: 2 }}).eachLayer(l => drawnItems.addLayer(l));
                    map.fitBounds(drawnItems.getBounds());
                    showNotification(`Identified and zoomed to ${drawnItems.getLayers().length} buildings.`);
                }
            } catch (error) {
                showNotification(`Could not fetch building data: ${error.message}`, true);
            } finally {
                identifySpinner.classList.add('hidden');
                identifyBtn.disabled = false;
                updateButtonStates();
            }
        }

        function generateNolliMap() {
            nolliContainer.innerHTML = '';
            const bounds = drawnItems.getBounds();
            const containerRect = nolliContainer.getBoundingClientRect();
            if (!bounds.isValid() || containerRect.width <= 0 || containerRect.height <= 0) return;

            const swPixel = map.latLngToContainerPoint(bounds.getSouthWest());
            const nePixel = map.latLngToContainerPoint(bounds.getNorthEast());
            const pixelWidth = nePixel.x - swPixel.x;
            const pixelHeight = swPixel.y - nePixel.y;
            if (pixelWidth <= 0 || pixelHeight <= 0) return;

            const scale = Math.min(containerRect.width / pixelWidth, containerRect.height / pixelHeight) * 0.95;
            const offsetX = (containerRect.width - (pixelWidth * scale)) / 2;
            const offsetY = (containerRect.height - (pixelHeight * scale)) / 2;
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute('width', containerRect.width);
            svg.setAttribute('height', containerRect.height);

            drawnItems.eachLayer(layer => {
                const geojson = layer.toGeoJSON();
                const coords = geojson.geometry.coordinates;
                const type = geojson.geometry.type;

                // This function takes an array of rings (a polygon's coordinates) and builds an SVG path string
                const buildPathForPolygon = (rings) => {
                    let pathData = '';
                    rings.forEach(ring => {
                        ring.forEach((coord, i) => {
                            const point = map.latLngToContainerPoint([coord[1], coord[0]]);
                            const scaledX = (point.x - swPixel.x) * scale + offsetX;
                            const scaledY = (point.y - nePixel.y) * scale + offsetY;
                            pathData += `${i === 0 ? 'M' : 'L'} ${scaledX.toFixed(2)} ${scaledY.toFixed(2)} `;
                        });
                        pathData += 'Z ';
                    });
                    return pathData;
                };

                if (type === 'Polygon') {
                    // Create one path for the polygon feature
                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    path.setAttribute('d', buildPathForPolygon(coords));
                    path.setAttribute('fill', '#000000');
                    path.setAttribute('fill-rule', 'evenodd');
                    svg.appendChild(path);
                } else if (type === 'MultiPolygon') {
                    // Create a separate path for each polygon within the multipolygon feature
                    coords.forEach(polygonCoords => {
                        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                        path.setAttribute('d', buildPathForPolygon(polygonCoords));
                        path.setAttribute('fill', '#000000');
                        path.setAttribute('fill-rule', 'evenodd');
                        svg.appendChild(path);
                    });
                }
            });
            nolliContainer.appendChild(svg);
        }
        
        function generate3DModel() {
            threeDContainer.innerHTML = ''; // Clear previous model/placeholder
            const height = parseFloat(buildingHeightInput.value) || 30;
            const rect = threeDContainer.getBoundingClientRect();

            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            const camera = new THREE.PerspectiveCamera(50, rect.width / rect.height, 0.1, 50000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(rect.width, rect.height);
            threeDContainer.appendChild(renderer.domElement);
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const light = new THREE.DirectionalLight(0xffffff, 0.5);
            light.position.set(200, 500, 300);
            scene.add(light);
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            const buildingsGroup = new THREE.Group();
            const center = drawnItems.getBounds().getCenter();
            const referenceZoom = 18;
            const centerPoint = map.project(center, referenceZoom);
            const metersPerPixel = 156543.03392 * Math.cos(center.lat * Math.PI / 180) / Math.pow(2, referenceZoom);
            
            drawnItems.eachLayer(layer => {
                const geojson = layer.toGeoJSON();
                const geomData = geojson.geometry.type === 'Polygon' ? [geojson.geometry.coordinates] : geojson.geometry.coordinates;
                geomData.forEach(polygonRings => {
                    const shapePoints = polygonRings[0].map(c => {
                        const p = map.project([c[1], c[0]], referenceZoom);
                        return new THREE.Vector2((p.x - centerPoint.x) * metersPerPixel, -(p.y - centerPoint.y) * metersPerPixel);
                    });
                    const shape = new THREE.Shape(shapePoints);
                    for (let i = 1; i < polygonRings.length; i++) {
                        const holePoints = polygonRings[i].map(c => {
                            const p = map.project([c[1], c[0]], referenceZoom);
                            return new THREE.Vector2((p.x - centerPoint.x) * metersPerPixel, -(p.y - centerPoint.y) * metersPerPixel);
                        });
                        shape.holes.push(new THREE.Path(holePoints));
                    }
                    const geometry = new THREE.ExtrudeGeometry(shape, { depth: height, bevelEnabled: false });
                    buildingsGroup.add(new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({ color: 0xcccccc })));
                });
            });
            
            // --- Create a container for both buildings and ground to center them together ---
            const containerGroup = new THREE.Group();
            containerGroup.add(buildingsGroup);
            
            const box = new THREE.Box3().setFromObject(buildingsGroup);
            const size = box.getSize(new THREE.Vector3());
            const boxCenter = box.getCenter(new THREE.Vector3());

            // --- Add ground plane ---
            const groundGeo = new THREE.PlaneGeometry(size.x * 1.5, size.y * 1.5);
            const groundMat = new THREE.MeshLambertMaterial({ color: 0xb0e0b0 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.position.set(boxCenter.x, boxCenter.y, box.min.z - 1); // Position plane below buildings
            containerGroup.add(ground);
            
            scene.add(containerGroup);
            containerGroup.position.sub(boxCenter); // Center the whole container

            const fov = camera.fov * (Math.PI / 180);
            const cameraZ = Math.abs(Math.max(size.x, size.y) / 1.5 / Math.tan(fov / 2));
            camera.position.set(0, size.y, cameraZ);
            controls.target.set(0, 0, 0);
            controls.update();

            function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
            animate();
            
            extractUrbanCharacteristics();
            tabUhi.disabled = false; // Enable simulation tab
            showNotification('3D model generated. You can now proceed to the UHI Simulation tab.');
        }
        
        function clearAll() {
            drawnItems.clearLayers();
            nolliContainer.innerHTML = '<div class="placeholder-text">Identify or draw buildings on the map to generate a Nolli-style plan.</div>';
            threeDContainer.innerHTML = '<div class="placeholder-text">Generate a 3D model to visualize the urban form.</div>';
            chartPlaceholder.style.display = 'flex';
            if(uhiChart) uhiChart.destroy();
            updateButtonStates();
            switchTab('nolli'); // Corrected from 'tab-nolli'
            showNotification('Map and results cleared.');
        }

        // --- Event Listeners ---
        map.on(L.Draw.Event.CREATED, (e) => { drawnItems.addLayer(e.layer); updateButtonStates(); });
        map.on('draw:edited', updateButtonStates);
        map.on('draw:deleted', updateButtonStates);

        identifyBtn.addEventListener('click', identifyBuildings);
        clearBtn.addEventListener('click', clearAll);
        generateNolliBtn.addEventListener('click', generateNolliMap);
        generate3dBtn.addEventListener('click', generate3DModel);

        function switchTab(activeTabId) {
            const tabs = [tabNolli, tab3D, tabUhi, tabAbout];
            const panels = [nolliPanel, threeDPanel, uhiPanel, aboutPanel];
            
            tabs.forEach((tab, index) => {
                const panel = panels[index];
                if (tab.id === `tab-${activeTabId}`) {
                    tab.className = 'whitespace-nowrap py-3 px-1 border-b-2 font-semibold text-sm border-blue-500 text-blue-600';
                    panel.classList.remove('hidden');
                } else {
                    tab.className = tab.disabled ? 
                        'whitespace-nowrap py-3 px-1 border-b-2 font-semibold text-sm border-transparent text-gray-400 disabled:opacity-50 disabled:hover:border-transparent disabled:cursor-not-allowed' :
                        'whitespace-nowrap py-3 px-1 border-b-2 font-semibold text-sm border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300';
                    panel.classList.add('hidden');
                }
            });
        }

        tabNolli.addEventListener('click', () => switchTab('nolli'));
        tab3D.addEventListener('click', () => switchTab('3d'));
        tabUhi.addEventListener('click', () => switchTab('uhi'));
        tabAbout.addEventListener('click', () => switchTab('about'));
        
        // --- UHI Simulation Logic ---
        function parseEPW(text) {
            const lines = text.split('\n').slice(8); // Skip header lines
            return lines.map(line => {
                const fields = line.split(',');
                if (fields.length < 22) return null;
                return {
                    dryBulb: parseFloat(fields[6]), // Dry Bulb Temperature
                    directNormalRad: parseFloat(fields[13]), // Direct Normal Radiation
                    diffuseHorizontalRad: parseFloat(fields[14]), // Diffuse Horizontal Radiation
                };
            }).filter(Boolean); // Remove any null entries from parsing errors
        }

        function extractUrbanCharacteristics() {
            if (drawnItems.getLayers().length === 0) return null;
            
            const bounds = drawnItems.getBounds();
            const sitePolygon = [bounds.getNorthWest(), bounds.getNorthEast(), bounds.getSouthEast(), bounds.getSouthWest()];
            const totalSiteArea = L.GeometryUtil.geodesicArea(sitePolygon);
            
            let totalFootprintArea = 0;
            let totalPerimeter = 0;
            drawnItems.eachLayer(layer => {
                const geojson = layer.toGeoJSON();
                const type = geojson.geometry.type;
                const coords = geojson.geometry.coordinates;

                const getRingPerimeter = (ring) => {
                    let perimeter = 0;
                    const latlngs = ring.map(p => L.latLng(p[1], p[0]));
                    if (latlngs.length < 2) return 0;
                    for (let i = 0; i < latlngs.length - 1; i++) {
                        perimeter += map.distance(latlngs[i], latlngs[i+1]);
                    }
                    perimeter += map.distance(latlngs[latlngs.length - 1], latlngs[0]);
                    return perimeter;
                }

                const processPolygon = (polygonCoords) => {
                    if (!polygonCoords || !polygonCoords[0]) return;
                    const outerRingLatLngs = polygonCoords[0].map(p => L.latLng(p[1], p[0]));
                    let area = L.GeometryUtil.geodesicArea(outerRingLatLngs);
                    totalPerimeter += getRingPerimeter(polygonCoords[0]);
                    
                    // Subtract area of holes and add their perimeter
                    for (let i = 1; i < polygonCoords.length; i++) {
                        const holeLatLngs = polygonCoords[i].map(p => L.latLng(p[1], p[0]));
                        area -= L.GeometryUtil.geodesicArea(holeLatLngs);
                        totalPerimeter += getRingPerimeter(polygonCoords[i]);
                    }
                    totalFootprintArea += area;
                };

                if (type === 'Polygon') {
                    processPolygon(coords);
                } else if (type === 'MultiPolygon') {
                    coords.forEach(processPolygon);
                }
            });

            const avgHeight = parseFloat(buildingHeightInput.value);
            const buildingDensity = totalSiteArea > 0 ? totalFootprintArea / totalSiteArea : 0;
            const avgCanyonWidth = (1 - Math.sqrt(buildingDensity)) / Math.sqrt(buildingDensity) * Math.sqrt(totalFootprintArea / drawnItems.getLayers().length);
            const aspectRatio = avgHeight / (avgCanyonWidth || 1); 

            const builtVolume = totalFootprintArea * avgHeight;
            const roofArea = totalFootprintArea;
            const wallArea = totalPerimeter * avgHeight;
            const totalSurfaceArea = wallArea + roofArea;
            const svRatio = builtVolume > 0 ? totalSurfaceArea / builtVolume : 0;

            document.getElementById('param-bldg-density').textContent = buildingDensity.toFixed(2);
            document.getElementById('param-aspect-ratio').textContent = aspectRatio.toFixed(2);
            document.getElementById('param-site-area').textContent = Math.round(totalSiteArea).toLocaleString();
            document.getElementById('param-built-volume').textContent = Math.round(builtVolume).toLocaleString();
            document.getElementById('param-roof-area').textContent = Math.round(roofArea).toLocaleString();
            document.getElementById('param-sv-ratio').textContent = svRatio.toFixed(3);

            return { buildingDensity, aspectRatio };
        }
        
        async function runUHISimulation() {
            runSimulationBtn.disabled = true;
            uhiSpinner.classList.remove('hidden');
            await new Promise(resolve => setTimeout(resolve, 50)); // Allow UI to update

            try {
                const greenCoverRatio = parseFloat(document.getElementById('green-cover-input').value) / 100;
                const buildingAlbedo = parseFloat(document.getElementById('building-albedo-input').value);
                const pavementAlbedo = parseFloat(document.getElementById('pavement-albedo-input').value);
                const wwr = parseFloat(document.getElementById('wwr-input').value);

                if (!epwFileInput.files[0]) throw new Error("Please select an EPW weather file.");
                const weatherData = parseEPW(await epwFileInput.files[0].text());
                const urbanParams = extractUrbanCharacteristics();
                const solstice = document.getElementById('solstice-select').value;
                
                const dayOfYear = solstice === 'summer' ? 172 : 355;
                const startHour = (dayOfYear - 1) * 24;
                const simulationData = weatherData.slice(startHour, startHour + 24);

                const buildingAreaRatio = urbanParams.buildingDensity;
                const groundAreaRatio = 1 - buildingAreaRatio;
                const weightedAlbedo = (buildingAlbedo * buildingAreaRatio) + (pavementAlbedo * groundAreaRatio * (1 - greenCoverRatio));
                const greenAreaRatio = groundAreaRatio * greenCoverRatio;

                let storedHeat = 0; // Cumulative heat stored in urban mass
                const heatStorageFactor = 0.65; // Proportion of solar energy stored vs immediately released
                const heatReleaseRate = 0.18; // Rate at which stored heat is released per hour at night

                const results = simulationData.map((hour, i) => {
                    const ruralTemp = hour.dryBulb;
                    const solarGainFactor = (hour.directNormalRad + hour.diffuseHorizontalRad) / 1000;
                    
                    // --- Model Factor: Urban Density & Geometry ---
                    // Denser areas and taller buildings (higher aspect ratio) trap more heat.
                    const densityFactor = urbanParams.buildingDensity * 5;
                    const aspectFactor = urbanParams.aspectRatio * 0.5;
                    
                    // --- Model Factor: Anthropogenic Heat ---
                    // A simple proxy for heat from human activities (HVAC, traffic).
                    // Assumes higher density and more windows (WWR) lead to more waste heat.
                    const anthropogenicHeat = (1.5 * urbanParams.buildingDensity) + (wwr * 2.0);

                    const absorbedSolarEnergy = solarGainFactor * (1 - weightedAlbedo);
                    
                    // --- Model Factor: Green Cover Cooling ---
                    // Evapotranspiration provides a cooling effect, especially during high solar radiation.
                    const greenCoverCoolingEffect = greenAreaRatio * solarGainFactor * 5;

                    let uhiEffect = 0;
                    if (solarGainFactor > 0.05) { // Daytime
                        const immediateHeating = absorbedSolarEnergy * (1 - heatStorageFactor);
                        storedHeat += absorbedSolarEnergy * heatStorageFactor;
                        uhiEffect = (densityFactor + aspectFactor) * immediateHeating - greenCoverCoolingEffect + anthropogenicHeat;
                    } else { // Night time
                        const heatReleased = storedHeat * heatReleaseRate;
                        storedHeat -= heatReleased; 
                        // Nighttime effect is a combination of released stored heat and constant anthropogenic heat.
                        uhiEffect = (heatReleased * densityFactor) + anthropogenicHeat;
                    }
                    
                    uhiEffect = Math.max(0, uhiEffect); 
                    return { hour: i, rural: ruralTemp, urban: ruralTemp + uhiEffect };
                });

                // --- Calculate and display average temperature difference ---
                const totalDifference = results.reduce((acc, curr) => acc + (curr.urban - curr.rural), 0);
                const avgDifference = results.length > 0 ? totalDifference / results.length : 0;
                displayResultsChart(results, avgDifference);

            } catch (error) {
                showNotification(`Simulation failed: ${error.message}`, true);
            } finally {
                runSimulationBtn.disabled = false;
                uhiSpinner.classList.add('hidden');
            }
        }

        function displayResultsChart(results, avgDifference) {
            chartPlaceholder.style.display = 'none';
            const ctx = document.getElementById('uhi-chart').getContext('2d');
            if (uhiChart) uhiChart.destroy();
            uhiChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: results.map(r => `Hour ${r.hour + 1}`),
                    datasets: [
                        { label: 'Urban Canyon Temp (°C)', data: results.map(r => r.urban), borderColor: 'rgb(239, 68, 68)', tension: 0.1, borderWidth: 2 },
                        { label: 'Rural Temp (°C)', data: results.map(r => r.rural), borderColor: 'rgb(59, 130, 246)', tension: 0.1, borderWidth: 2 }
                    ]
                },
                options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: `UHI Simulation Results (Avg. ΔT: ${avgDifference.toFixed(2)}°C)` }}, scales: { y: { title: { display: true, text: 'Temperature (°C)' }}}}
            });
        }
        
        epwFileInput.addEventListener('change', () => {
            runSimulationBtn.disabled = epwFileInput.files.length === 0;
            epwFileNameEl.textContent = epwFileInput.files.length > 0 ? epwFileInput.files[0].name : '';
        });
        runSimulationBtn.addEventListener('click', runUHISimulation);

        // Initial setup
        updateButtonStates();
    </script>
</body>
</html>

